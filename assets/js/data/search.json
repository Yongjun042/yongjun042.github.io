[ { "title": "CRA와 웹팩5 호환성 해결하기", "url": "/posts/CRA_Webpack5-copy/", "categories": "Blog, Develope", "tags": "React, CRA, webpack", "date": "2022-01-02 22:55:00 +0900", "snippet": "CRA(Create React App)으로 리액트 앱을 만들고 웹팩 5을 적용하게 되면 웹팩 5부터 polyfill 을 기본으로 지원하지 않기 때문에 오류가 생긴다. polyfill은 브라우저 호환성을 위한 도구지만 불필요한 경우가 많아 제외되었다.ERROR in ./node_modules/readable-stream/lib/_stream_readable.js 46:13-37Module not found: Error: Can&#39;t resolve &#39;buffer&#39; in &#39;C:\\ *\\node_modules\\readable-stream\\lib&#39;BREAKING CHANGE: webpack &amp;lt; 5 used to include polyfills for node.js core modules by default.This is no longer the case. Verify if you need this module and configure a polyfill for it.If you want to include a polyfill, you need to: - add a fallback &#39;resolve.fallback: { &quot;buffer&quot;: require.resolve(&quot;buffer/&quot;) }&#39; - install &#39;buffer&#39;If you don&#39;t want to include a polyfill, you can use an empty module like this: resolve.fallback: { &quot;buffer&quot;: false }해당 오류를 해결하려면 웹팩 설정을 수정해야 되는데 npm eject를 사용할 경우 CRA의 장점인 편리함을 잃게 되기 때문에 customize-cra와 react-app-rewired를 이용해 수정을 해준다. 웹팩뿐만 아니라 바벨도 수정 가능하다.yarn add react-app-rewired customize-cra --devnpm install --save-dev react-app-rewired customize-cra패키지 설치 후 cofig-overides.js파일을 최상단에 생성 후 오류에 맞춰 작성해준다.// config-overrides.jsconst { override, loaders } = require(&#39;customize-cra&#39;);module.exports = function override (config, env) { console.log(&#39;override&#39;) let loaders = config.resolve loaders.fallback = { &quot;buffer&quot;: false, &quot;crypto&quot;: require.resolve(&quot;crypto-browserify&quot;), //... 추가 설정 } return config}해당 기능이 필요없는 경우 false로 사용하지 않고, 필요한 경우 해당 패키지를 설치한 후 require.resolve()로 적용시켜주면 된다.// pacakage.json{ &quot;scripts&quot;: { &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, ... }, ...}그리고 다음과 같이 react-script ...부분을 react-app-rewired로 바꿔 적용시켜주면 된다." }, { "title": "ECMAScript 파이프라인 제안서 2단계 진입", "url": "/posts/ECMAscript_pipe_2nd/", "categories": "Blog, Develope", "tags": "javascript, ecmascript, pipe", "date": "2021-11-23 11:54:00 +0900", "snippet": "링크파이프라인이 다음과 같은 EcmaScript의 총 5단계(0~4)의 제안 과정 중 2단계에 진입했습니다. 2단계는 공식 언어를 이용해서 문법과 의미를 설명하는 문서를 작성하는 단계로 피드백을 받는 3단계를 거치면 최종적으로 4단계에서 공식 사양이 됩니다. 해당 문서의 일부를 정리해보았습니다.기존 방식기존에는 값을 가지고 연속적인 연산을 할 경우값을 연산의 인자로 넘겨주는 중첩 연산(three(two(one(value))))이나 값의 메소드를 이용해 연산(value.one().two().three())을 해야 했습니다.중첩 연산console.log( chalk.dim( `$ ${Object.keys(envars) .map(envar =&amp;gt; `${envar}=${envars[envar]}`) .join(&#39; &#39;) }`, &#39;node&#39;, args.join(&#39; &#39;)));장점 모든 종류의 문법에 대해 사용이 가능합니다.단점 연산을 중첩해서 사용할 경우 읽는 방향이 오른쪽에서 왼쪽으로 일반적인 방식의 반개이기 때문에 읽기가 힘들어집니다. 인자값이 여러개일 경우 읽는 방향을 여러번 바꿔야 합니다. 수정하기가 어렵습니다.메소드 체이닝 연산jQuery가 사용하는 방식입니다.장점 읽는 방식은 왼쪽에서 오른쪽으로 일정합니다. 함수의 인자값이 함수의 이름으로 묶여있어 수정이 용이합니다. 자바스크립트의 await, yield, 배열 리터럴, 등과 같은 다른 문법을 사용할 수 없습니다.단점 메소드 체이닝을 이용할 경우 값이 해당 함수를 메소드 형식으로 갖고있을 경우만 사용이 가능합니다.임시 변수 방식const envarString = Object.keys(envars) .map(envar =&amp;gt; `${envar}=${envars[envar]}`) .join(&#39; &#39;);const consoleText = `$ ${envarString}`;const coloredConsoleText = chalk.dim(consoleText, &#39;node&#39;, args.join(&#39; &#39;));console.log(coloredConsoleText);임시 변수를 사용해서 파이프와 비슷한 효과를 낼 수 있습니다. 하지만 코드가 너무 길어지고 많은 변수명을 추가로 지어야 합니다.단일 변수를 사용할 경우 연산 도중에 값이 바뀔 수 있다는 단점이 있습니다.// setupfunction one () { return 1; }function double (x) { return x * 2; }let _;_ = one(); // _ = 1._ = double(_); // _ = 2._ = Promise.resolve().then(() =&amp;gt; // 2가 출력되지 안습니다! // `_`가 아래에서 쟇할당되었기 때문에 1을 출력합니다. console.log(_));// promise 콜백 전에 _가 1이 됩니다._ = one(_);파이프 방식Object.keys(envars) .map(envar =&amp;gt; `${envar}=${envars[envar]}`) .join(&#39; &#39;) |&amp;gt; `$ ${%}` |&amp;gt; chalk.dim(%, &#39;node&#39;, args.join(&#39; &#39;)) |&amp;gt; console.log(%);파이프는 |&amp;gt;를 이용해 왼쪽에 있는 값을 오른쪽으로 념겨주는 역할을 합니다.Hack 방식과 F#방식 중 Hack 방식이 선택되었습니다.Hack 표현식value |&amp;gt; one(%) |&amp;gt; two(%) |&amp;gt; three(%)와 같은 방식으로 작동합니다. 파이프 기호의 우항에는 표현식이 들어가야 되고 %기호를 이용해 좌항의 값이 들어갈 자리를 정합니다. 우항에는 어떤 표현식이든 들어갈 수 있다는 장점이 있습니다. 단항 연산의 경우에도 (%)와 같이 표현을 해줘야 한다는 단점이 있습니다. F# 단항 함수value |&amp;gt; one |&amp;gt; two |&amp;gt; three와 같은 방식으로 작동합니다. 우항에는 항상 단항 함수로 평가되어야하고 좌항의 값은 단일 매개변수가 됩니다. 단항 함수를 호출할 경우 매우 간단하다는 장점이 있습니다. 단항 함수가 아닌 다른 구문의 경우 화살표 함수로 감싸야 된다는 단점이 있습니다. value |&amp;gt; x=&amp;gt; foo(1, x) await와 yield의 경우 포함하고 있는 함수로 스코프가 제한되어 있기 때문에 value |&amp;gt; await를 awaiting promise로 value |&amp;gt; yield를 yielding generatir로 따로 취급을 해 줘야 합니다.단항 함수가 아닌 다른 구문이 더 자주 쓰이고, 제안된 다른 기능과의 호환이 더 좋다는 점, F#의 경우 특수 케이스가 존재한다는 점, value |&amp;gt; someFunction + 1와 같은 식의 경우 Hack 방식은 문법 오류지만 F#방식은 런타임 오류라는 점, TC39에서 F#파이프 방식을 여러번 반려했다는 점에서 Hack 방식이 선택되었습니다.규칙 topic reference인 %(임시)는 영항 연산자로 topic value의 위치를 나타내면서 렉시컬 스코프이고, 불변값입니다. 파이프 연산자인 |&amp;gt;는 화살표 함수=&amp;gt;, 대입 연산자=, +=, 생성 연산자yield와 우선순위 가 같습니다. 더 높은 우선순위를 가지고 있는 연산자는, 하나뿐입니다. v =&amp;gt; v |&amp;gt; % == null |&amp;gt; foo(%, 0)는 v =&amp;gt; (v |&amp;gt; (% == null) |&amp;gt; foo(%, 0))와 같이 묶을 수 있습니다. value |&amp;gt; foo + 1 는 %가 없기 때문에 올바르지 않은 구문입니다. 또한 %는 파이프 바깥에서 사용할 수 없습니다. 같은 우선순위를 가지고 있는 연산자는 파이프와 사용할 수 없고 사용하게 될 경우 순서를 명시해줘야 합니다.a |&amp;gt; b ? % : c |&amp;gt; %.d의 경우 a |&amp;gt; (b ? % : c) |&amp;gt; %.d나 a |&amp;gt; (b ? % : c |&amp;gt; %.d)로 작성해야 합니다. 동적으로 컴파일되는 코드는 해당 코드 바깥에서 사용할 수 없습니다. v |&amp;gt; eval(&#39;% + 1&#39;)는 올바르지 않은 구문입니다. 사이드이펙트는 ,를 이용해 value |&amp;gt; (sideEffect(), %)와 같이 사용할 수 있습니다." }, { "title": "컴포넌트 기반 웹 디자인 살펴보기", "url": "/posts/Next_responsive/", "categories": "Blog, Develope", "tags": "CSS, Web, Responsive", "date": "2021-11-18 21:09:16 +0900", "snippet": "구글에서 올린 새로운 반응형: 컴포넌트 기반 세상의 웹 디자인을 읽고 정리해 보았다.기존의 뷰포인트 기반 미디어 쿼리는 유저의 요구를 전부 충족시키지도 못하고 컴포넌트 스스로 반응형 스타일을 인젝션할 수도 없다고 하면서 해당 문제를 해결할 수 있는 기능들을 소개하였다. 아직 개발중인 기술도 소개가 되었다.##사용자 반응성사용자의 요구에 따라 페이지를 보여줄 수 있는 미디어 옵션들을 소개했다.prefers-reduced-motion, prefers-contrast, prefers-reduced-transparency, prefers-color-scheme, inverted-colors 등이 있고 아래 2개의 옵션을 제외하고 현재 기준으로 미구현이거나 구현된 브라우저가 거의 없다.prefers-reduced-motionADHD인 사람들이나 광과민성을 가진 사람들에게 도움을 줄 수 있는 옵션이다. 또한 저사양 기기에서의 퍼포먼스 향상과 배터리 절약을 기대할 수 있다. 다만 모션을 완전히 없애는 것이 아니라 강조를 위한 필수적인 모션은 남겨둬야 하는 것이 핵심이다.prefers-color-scheme다크모드를 적용하거나 페이지의 악센트 컬러를 변경할 수 있다. 이때 다크 모드는 배경을 단순히 어둡게 하면 안된다. 채도를 감소시켜 눈을 편안하게 해주거나 또한 그림자를 이용한 깊이 표현도 다크 모드에서는 눈에 띄지 않기 때문에 튀어나온 느낌을 위해서 요소의 색을 밝게 해야 된다.CSS 컨테이너 쿼리엘리먼트 쿼리라고도 불리는 이 쿼리는 부모 요소의를 기반으로 반응형 디자인을 할 수 있는 쿼리이다. 전체 페이지가 아니라 부모에 따라 반응을 하기 때문에 더 세부적으로 설정을 할 수 있다.스코프 스타일많은 프레임워크나 css모듈에서 지원하는 스코프 스타일이 네이티브로 지원될 수도 있다. 시작점과 끝점 지정할 수 있다.폼팩터에 반응하기듀얼스크린에서 웹페이지를 적절하게 표현할 수 있는env(fold-top), screen-spanning과 같은 요소들이 있다. 사실상 서피스 듀오 전용 기술이지 않나 싶다." }, { "title": "Error listen EACCES permission denied 해결법", "url": "/posts/Eaccess_denied/", "categories": "Blog, Develope", "tags": "Error, Windows", "date": "2021-08-09 21:09:00 +0900", "snippet": "해당 포트가 사용중이라는데 문제는 윈도우에 netstat을 이용해서 찾아봐도 해당 포트를 사용중인 프로그램은 없었다.사실 전에도 포트 사용중 오류가 있었는데 이건 포트 고정이라 다른 오류 메세지가 떴고 이 오류로 검색해 해결책을 찾았다.net stop winnatnet start winnatcmd창이나 PowerShell에 다음 명령어를 쳐 winnat 서비스를 껐다 키면 된다.Hyper-V의 가상 컴퓨터의 포트 연결에 쓰이는데 뭔가 버그가 있는 것 같다.윈도우 업데이트를 할때도 일부 포트가 막힌다고도 한다." }, { "title": "노트", "url": "/posts/Note/", "categories": "Blog, Develope", "tags": "note", "date": "2021-07-28 17:06:00 +0900", "snippet": "헤드리스 리액트 컴포넌트링크일반 React 컴포넌트의 경우 커스터마이징을 하려면 CSS 오버라이딩을 이용해야 되는데 번거롭고 오버라이딩이 되지 않는 경우가 있다.HeadLess는 스타일 부분과 제어부분을 나눠 제어부분만 만들어 놓는 것이다.기본적인 데이터 로직은 변경 가능성이 낮고 스타일이 추상화되면 스타일 재정의를 위한 인터페이스를 열어둬야 돼 유지보수가 어렵다.자료구조만 정의가 되어있고 해당 데이터를 받아서 적절하게 뿌려주는 느낌.예제코드로 학습하기링크예제코드로 학습하기한글 유니코드 처리 방식링크유니코드 정규화 규칙에는 4가지가 있다.NFD는 자모를 분해해서 저장하고 NFC는 하나의 문자로 합쳐서 저장을 한다. NFKC와 NFKD의 경우 특수문자도 분해를 해 한글음절/자모로 분해를 해 특수문자 처리에 유용하다.옛한글의 경우 NFC형태로 저장이 불가능하고 자소 규칙이 표준화되어있지 않으므로 정렬 시 주의를 요한다.html 기본 태그링크각종 html 기본 제공 태그들. 왠만한건 다 생기는 느낌이다.리액트 useeffect 작동 방식링크링크" }, { "title": "npm unpublish에 제한조건이 생긴 이유", "url": "/posts/Npm_unpublish/", "categories": "Blog, Develope", "tags": "npm, javascript", "date": "2021-07-25 15:35:00 +0900", "snippet": "2016년 3월 22일 수많은 자바스크립트 프로그래머들은 npm ERR! 404 ‘left-pad’ not in the npm registry. 라는 오류를 보게 된다.당연히 해당 패키지를 들어보지도 못한 사람들은 해당 패키지가 무엇인지 찾기 시작했다.해당 함수는 11줄의 코드로 이루어져 왼쪽에 특정한 문자를 채워주는 단순한 함수이다.문제는 React를 포함한 수많은 패키지들이 이 단순한 기능을 직접 구현하지 않고 패키지를 사용했다는 것이다.해당 오류는 2시간 후 npm에서 해당 패키지를 다시 퍼블리싱하는것으로 해결이 되었다.해당 패키지가 내려간 이유는 다음과 같았다.제작자 Koçulu가 kik라는 이름의 패키지를 만들었는데 같은 이름을 가진 캐나다의 메세지 회사에서 해당 패키지의 이름을 변경해달라고 연락을 한 것이다.거절의 의사를 밝히자 회사에서 법적 조치를 취한다고 하고 Koçulu는 항의의 표시로 퍼블리싱한 모든 패키지를 내려버린 것이다.이렇게 한 사람의 깃허브 스타 10개를 받은 패키지가 내려가자 전세계 javascript 개발자에게 영향을 끼친 것이다.자바스크립트의 기본 생태계를 파괴할 수 있기 때문에 npm의 퍼블리싱 취소 규정이 생기게 되었다.퍼블리시한지 24시간이 지나면 의존된 패키지가 존재하지 않다는 조건 하에 취소가 가능해진다. 의존된 패키지가 존재할 경우 해당 패키지 관리자에게 문의를 해 의존성을 제거해달라고 하거나 패키지의 권한을 넘겨야 한다. 그리고 해당 패키지의 이름은 Security placeholder package로 들어가 동일한 이름을 이용한 악성코드 활용에 이용되지 않도록 처리가 된다.그 이후 사람들의 요청에 의해 24시간에서 72시간으로 시간이 늘어났고 일부 조건이 생겼다.많은 사람들이 사용하지 않아야 되기 때문에 저번주의 다운로드수가 300을 넘지 말아야 한다.다른 소유자의 의견 없이 삭제가 될 수 있기 때문에 주의하는 차원에서 해당 패키지의 소유자는 한명이여야 한다.라는 규정이 2개 추가되었다." }, { "title": "깃허브 코파일럿 소개 요약", "url": "/posts/Copilot_intro/", "categories": "Blog, Develope", "tags": "GitHub, Ide", "date": "2021-06-30 14:30:00 +0900", "snippet": "공식 페이지깃허브에서 공개한 함수 자동 작성 AI 확장 프로그램주석 -&amp;gt; 코드 변환반복되는 코드 자동 작성테스트 코드 작성JavaScript, Python, Ruby, TypeScript, Go 지원기본 소개Visual Studio Code Extension으로 제공. 다른 IDE는 현재 계획 없음.프리뷰 기간에는 사용자 수를 제한하고 있음. 유료버전 가능성 있음.OpenAI Codex를 이용해 소스코드와 자연어를 인식해서 처리.첫 시도에 43%의 정확도 10번의 시도 후 57%의 정확도를 보임.작은 함수들로 나누고, 이름을 명확하게 짓고, 주석을 잘 달았을 경우 더 좋은 성능을 보임.오직 현재 작업중인 파일 내용만 이해하기 때문에 사용자 정의 타입이 다른 파일에 있을 경우 해당 내용을 현재 파일에 붙여넣는 것이 좋음.파일의 모든 맥락을 기억할 수 없기 때문에 직전의 맥락만 사용이 됨.옛날 문법이나 라이브러리를 추천할 수도 있음.AI소개영어와 공개된 소스코드 -깃허브 포함- 이용0.1%로 트레이닝 셋의 내용이 나왔고 주로 맥락이 없는 빈 페이지나 널리 쓰이는 해법이 있는 경우 발생.개인정보를 노출시키지 않기 위해 필터링을 하였지만 아주 낮은 확률로 노출이 될 수 있음.대부분 개인정보같아 보여도 AI가 만든 가짜 개인정보.안전하지 않은 코드나 더이상 지원되지 않는 함수를 사용할 수 도 있음.혐오적이거나 편향된 결과를 필터링했지만 해당 정보가 나올 수 도 있음.좀 더 생산적이고 흥미로운 작업에 집중할 수 있을 것이고, 진입장벽을 낮출 것으로 예상사용자 자료 수집파일의 일부를 서버로 보냄. 제안된 코드를 사용했는지 여부를 기록. 추후 선택 여부 결정수집된 자료는 자동으로 분석되고 모델 개선이나 악용 여부를 위해서만 사람이 읽어봄. 해당 데이터는 다른 사용자에게 공유되지 않음." }, { "title": "윈도우 썸네일 만들기", "url": "/posts/Window_Thumbnail/", "categories": "Blog, Develope", "tags": "C#, Windows", "date": "2021-05-23 22:00:00 +0900", "snippet": "윈도우 자체에서 지원하지 않는 파일들의 썸네일 이미지들을 만들어보자.블루레이 리핑해서 가지고 있을 때 전부 iso기본이미지라 구분이 너무 힘들어서 만들었다.윈도우에서 썸네일 프로그램을 만들려면 IThumbnailProvider 인터페이스를 이용해서 코드를 C++로 짠 다음에 COM서버로 올려야되는데 다행히 해당 기능을 C#으로 짤 수 있게 하는 C# 프로그램이 있다.일단 커스텀 썸네일 프로그램을 만들 수 있는 기존의 프로그램이 2개 있다. 둘 다 파일을 읽어들여서 크기에 맞게 썸네일을 Bitmap으로 리턴하면 된다.PowerToys링크마이크로소프트에서 만든 윈도우 편의성 툴.previewpane에 썸네일 확장 프로그램 코드가 있고 IInitializeWithFile, IThumbnailProvider를 상속해서 XYZThumbnailHandler를 생성해서 모듈을 추가할 수 있다.문제는 해당 문서가 오래된 거라 실제 코드와 다른 점이 많다. 기존에 있는 svg확장프로그램을 참고해서 dll까지 만들 수 있었지만 해당 dll을 해당 프로그램에 연결하는것에 실패해서 여러 방법을 찾다가 포기. 설치하려면 전체 프로젝트를 컴파일해야되서 용량도 커지고 번거롭다.SharpShell링크.NET프로그램을 이용한 쉘 스크립트 확장 프로그램이다.SharpThumbnailHandler를 상속해서 만들 수 있다. 튜토리얼도 존재한다. 샘플이 깃허브에 존재하는데 AssociationType.FileExtension대신 .ClassOfExtension을 잘못 사용하고 있다. 다른 문서에서는 ClassOfExtension을 지원 안한다고 써져있는데 뭐가 잘못되는건지 모르겠다.문제는 자잘한 오류가 꽤 많은 것 같다. 실행이 안되서 엄청 헤맸는데 어느순간부터 오류를 뿜던 코드가 갑자기 된다. ServerManager를 이용해서 디버깅과 설치/삭제가 가능하다." }, { "title": "터미널 더 편하게 이용하기", "url": "/posts/Better_Terminal/", "categories": "Blog, Develope", "tags": "terminal, powerline", "date": "2021-02-26 19:00:00 +0900", "snippet": "터미널을 더욱 더 유용하고 이쁘게 사용할 수 있는 프로그램을 설치해봅시다.윈도우 터미널 설치하기마이크로소프트 스토어에서 윈도우 터미널을 설치합니다.링크윈도우 터미널을 이용하면 배경화면 변경같은 꾸미기 기능과 여러 명령어 창을 탭을 이용해서 한 창 위에 띄울 수 있습니다.탭 +옆에 있는 아래 화살표를 눌러 설정을 열 수 있습니다. json파일로 되어있습니다.{ //폰트 설정 &quot;font-family&quot;: &quot;Cascadia Code PL&quot;, //색상표 변경 &quot;colorScheme&quot;: &quot;One Half Dark&quot;, //배경 반투명 &quot;useAcrylic&quot;: true, //반투명 투명도 &quot;acrylicOpacity&quot;: 0.9, //배경 사진 적용 &quot;backgroundImage&quot;: &quot;C://bg.png&quot;}이 외에도 여러가지 설정이 가능합니다.공식문서터미널 기능 추가하기Powershell(윈도우)PsReadline을 이용한 명령어 예측 및 자동완성Powershell의 경우 PsReadline을 이용해서 자동완성과 깃허브 단축명령어를 사용할 수 있습니다.Install-Module -Name PSReadLine -RequiredVersion 2.1.0명령어로 설치를 합니다.Set-PSReadLineOption -PredictionSource History명령어로 히스토리 기반으로 명령어를 자동완성해주는 기능을 추가합니다. 해당 명령어가 먹히지 않을 경우 C:\\Program Files\\WindowsPowerShell\\Modules\\PSReadline의 경로로 가서 2.0.0 구버전 폴더를 삭제하면 됩니다.notepad $PROFILE을 입력해 파워쉘 프로필을 연 다음 다음 내용을 추가합니다.# 기록기반 자동완성 켜기Set-PSReadLineOption -PredictionSource History# 자동완성 폰트색 변경 InlinePrediction = &#39;#색상코드&#39;Set-PSReadLineOption -Colors @{ InlinePrediction = &#39;#2F7004&#39;}# 자동완성목록 보이기Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete# 화살표로 자동완성목록 이동Set-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackwardSet-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward&amp;amp; $profile을 입력해 변경된 프로필 설정을 불러올 수 있습니다.다음과 같이 나오면 성공입니다.posh-git을 이용한 깃허브 단축 명령어Install-Module posh-git -Scope CurrentUser 명령어로 설치 후notepad $PROFILE 명령어로 프로필을 연다음Import-Module posh-git을 추가하면 됩니다.리눅스zsh, oh-my-zsh 을 이용한 터미널 기능 추가우리가 쓰는 프로그램 명령어를 입력받는 창을 쉘이라고 합니다.리눅스의 기본 쉘은 bash인데 zsh는 bash의 명령어와 호환되면서 여러 플러그인을 지원하는 쉘입니다. 대부분 기능에서 zsh가 더 좋습니다. Oh-my-zsh는 zsh를 쉽게 관리하게 해주는 프로그램입니다.sudo apt install -y zshchsh -s $(which zsh)명령어를 이용해 zsh를 설치하고 쉘을 zsh로 바꿔줍니다.다음과 같은 선택지가 뜰텐데 1번을 눌러 zsh설정파일인 .zshrc파일을 생성해줍니다.sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;을 입력하면 oh-my-zsh설치가 완료됩니다.플러그인 설치하기zsh-autosuggestions 을 다음 명령어로 설치해 자동완성 기능을 사용할 수 있습니다.git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestionszsh-syntax-highlighting 을 다음 명령어로 설치해 명령어의 구문을 다른 색으로 강조할 수 있습니다.git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting해당 플러그인들을 설치했으면 ‘vi ~/.zshrc’명령올 zsh설정파일을 연 다음 plugins를 찾아서 다음과 같이 추가해줍니다.plugins=(git zsh-syntax-highlighting zsh-autosuggestions)git은 git단축키 프로그램으로 기본으로 깔려있습니다.source ~/.zshrc을 입력하면 zsh설정파일을 다시 불러와 적용할 수 있습니다.Oh-my-Posh 설치하기Oh-my-Posh는 터미널 테마를 꾸밀 수 있는 크로스플랫폼 프로그램입니다.보통 폰트에는 사용되지 않는 기호가 사용되서 Nerd Fonts 해당 폰트를 다운받아 사용해야 깨지는 글자가 없이 나옵니다.PowershellInstall-Module oh-my-posh -Scope CurrentUser``` 명령어로 설치할 수 있습니다.```sehllGet-PoshThemes을 이용해서 기본 제공되는 테마를 살펴볼 수 있습니다. Oh-my-Posh 첫부분에 있는 사진처럼 나옵니다.notepad $PROFILE 으로 파워쉘 설정 파일을 연다음Set-PoshPrompt -Theme jandedobbeleer-Theme {테마이름}으로 테마를 변경할 수 있습니다.ZSHwget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-poshchmod +x /usr/local/bin/oh-my-posh명령어로 설치 후mkdir ~/.poshthemeswget https://github.com/JanDeDobbeleer/oh-my-posh/releaseslatest/download/themes.zip -O ~/.poshthemes/themes.zipunzip ~/.poshthemes/themes.zip -d ~/.poshthemeschmod u+rw ~/.poshthemes/*.jsonrm ~/.poshthemes/themes.zip명령어로 테마를 다운로드합니다.for file in ~/.poshthemes/*.omp.json; do echo &quot;$file\\n&quot;;oh-my-posh --config $file --shell universal; echo &quot;\\n&quot;; done;명령어로 기본 제공되는 테마를 살펴볼 수 있습니다. Oh-my-Posh 첫부분에 있는 사진처럼 나옵니다.~/.zshrc파일에 다음과 같이 추가합니다.eval &quot;$(oh-my-posh --init --shell zsh --config ~/.poshthemes/jandedobbeleer.omp.json)&quot;source ~/.zshrc로 oh my phsh를 적용합니다.--config ~/.poshthemes/{테마 이름}.omp.json으로 테마를 바꿀 수 있습니다.커스텀 테마기본 제공되는 테마 파일과 공식 문서를 참조해서 입맛대로 테마를 만들 수 있습니다.Powershell의 경우 -Theme {테마경로} zsh의 경우 --config {테마경로}로 커스텀 테마를 적용할 수 있습니다." } ]
